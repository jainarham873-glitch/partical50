<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle 50</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #input_video { display: none; }
    </style>
</head>
<body>

    <video id="input_video"></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        camera.position.z = 10;

        // --- PARTICLE ENGINE ---
        const count = 12000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const velocities = new Float32Array(count * 3);

        for (let i = 0; i < count; i++) {
            positions[i * 3] = (Math.random() - 0.5) * 10;
            positions[i * 3 + 1] = (Math.random() - 0.5) * 10;
            positions[i * 3 + 2] = (Math.random() - 0.5) * 10;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            size: 0.035,
            color: 0x00ffff,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);

        // --- GESTURE STATE ---
        let targetPos = new THREE.Vector3(0, 0, 0);
        let expansionFactor = 1.0;
        let rotationSpeed = 0.005;

        // --- MEDIAPIPE ---
        const videoElement = document.getElementById('input_video');
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.6,
            minTrackingConfidence: 0.6
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // Handle 1 or 2 hands
                const landmarks1 = results.multiHandLandmarks[0];
                const palm1 = landmarks1[9];

                // Map hand 1 to screen coordinates
                targetPos.x = (palm1.x - 0.5) * -20;
                targetPos.y = (palm1.y - 0.5) * -15;

                if (results.multiHandLandmarks.length === 2) {
                    // Two-hand zoom logic
                    const landmarks2 = results.multiHandLandmarks[1];
                    const palm2 = landmarks2[9];
                    const dist = Math.sqrt(
                        Math.pow(palm1.x - palm2.x, 2) + 
                        Math.pow(palm1.y - palm2.y, 2)
                    );
                    expansionFactor = dist * 8; // Zoom level
                    rotationSpeed = (palm1.x - palm2.x) * 0.1; // Rotate based on hand tilt
                } else {
                    expansionFactor = 1.0;
                    rotationSpeed = 0.005;
                }
            }
        });

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 1280, height: 720
        });
        cameraFeed.start();

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const pos = geometry.attributes.position.array;
            
            // Apply movement to every particle
            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                
                // Drift toward the hand
                pos[i3] += (targetPos.x - pos[i3]) * 0.02 * expansionFactor;
                pos[i3 + 1] += (targetPos.y - pos[i3 + 1]) * 0.02 * expansionFactor;
                
                // Add some chaotic "hologram" jitter
                pos[i3] += (Math.random() - 0.5) * 0.05;
                pos[i3+1] += (Math.random() - 0.5) * 0.05;
            }

            points.rotation.y += rotationSpeed;
            points.rotation.z += 0.001;

            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        animate();

        // Responsive Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
